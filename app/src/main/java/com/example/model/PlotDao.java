package com.example.model;

import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteStatement;

import de.greenrobot.dao.AbstractDao;
import de.greenrobot.dao.Property;
import de.greenrobot.dao.internal.DaoConfig;

// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
/** 
 * DAO for table "PLOT".
*/
public class PlotDao extends AbstractDao<Plot, Long> {

    public static final String TABLENAME = "PLOT";

    /**
     * Properties of entity Plot.<br/>
     * Can be used for QueryBuilder and for referencing column names.
    */
    public static class Properties {
        public final static Property Id = new Property(0, Long.class, "id", true, "_id");
        public final static Property Url = new Property(1, String.class, "url", false, "URL");
        public final static Property Parcel = new Property(2, Integer.class, "parcel", false, "PARCEL");
        public final static Property Project = new Property(3, Integer.class, "project", false, "PROJECT");
        public final static Property Name = new Property(4, String.class, "name", false, "NAME");
        public final static Property Default_aeq = new Property(5, String.class, "default_aeq", false, "DEFAULT_AEQ");
        public final static Property Calculate_by_species = new Property(6, Boolean.class, "calculate_by_species", false, "CALCULATE_BY_SPECIES");
        public final static Property Region = new Property(7, String.class, "region", false, "REGION");
        public final static Property Root_to_shoot_ratio = new Property(8, Float.class, "root_to_shoot_ratio", false, "ROOT_TO_SHOOT_RATIO");
        public final static Property Mapped_dimensions = new Property(9, String.class, "mapped_dimensions", false, "MAPPED_DIMENSIONS");
        public final static Property Reported_dimensions = new Property(10, String.class, "reported_dimensions", false, "REPORTED_DIMENSIONS");
        public final static Property Center_point_type = new Property(11, String.class, "center_point_type", false, "CENTER_POINT_TYPE");
        public final static Property Cp_coord_latitude = new Property(12, Double.class, "cp_coord_latitude", false, "CP_COORD_LATITUDE");
        public final static Property Cp_coord_longitude = new Property(13, Double.class, "cp_coord_longitude", false, "CP_COORD_LONGITUDE");
        public final static Property Reported_shape = new Property(14, Short.class, "reported_shape", false, "REPORTED_SHAPE");
        public final static Property Mapped_shape = new Property(15, Short.class, "mapped_shape", false, "MAPPED_SHAPE");
        public final static Property Has_soil_data = new Property(16, Boolean.class, "has_soil_data", false, "HAS_SOIL_DATA");
        public final static Property Has_biomass_data = new Property(17, Boolean.class, "has_biomass_data", false, "HAS_BIOMASS_DATA");
        public final static Property Has_deadwood_data = new Property(18, Boolean.class, "has_deadwood_data", false, "HAS_DEADWOOD_DATA");
        public final static Property Has_litter_data = new Property(19, Boolean.class, "has_litter_data", false, "HAS_LITTER_DATA");
        public final static Property Mapped_area = new Property(20, Float.class, "mapped_area", false, "MAPPED_AREA");
        public final static Property Reported_area = new Property(21, Float.class, "reported_area", false, "REPORTED_AREA");
        public final static Property Area = new Property(22, Float.class, "area", false, "AREA");
        public final static Property Tree_species_count = new Property(23, Integer.class, "tree_species_count", false, "TREE_SPECIES_COUNT");
        public final static Property Tree_count = new Property(24, Integer.class, "tree_count", false, "TREE_COUNT");
        public final static Property FileName = new Property(25, String.class, "fileName", false, "FILE_NAME");
        public final static Property Image_file_path = new Property(26, String.class, "image_file_path", false, "IMAGE_FILE_PATH");
        public final static Property Photo_direction = new Property(27, String.class, "photo_direction", false, "PHOTO_DIRECTION");
        public final static Property Photo_date = new Property(28, java.util.Date.class, "photo_date", false, "PHOTO_DATE");
    };

    private DaoSession daoSession;


    public PlotDao(DaoConfig config) {
        super(config);
    }
    
    public PlotDao(DaoConfig config, DaoSession daoSession) {
        super(config, daoSession);
        this.daoSession = daoSession;
    }

    /** Creates the underlying database table. */
    public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
        String constraint = ifNotExists? "IF NOT EXISTS ": "";
        db.execSQL("CREATE TABLE " + constraint + "\"PLOT\" (" + //
                "\"_id\" INTEGER PRIMARY KEY ," + // 0: id
                "\"URL\" TEXT," + // 1: url
                "\"PARCEL\" INTEGER," + // 2: parcel
                "\"PROJECT\" INTEGER," + // 3: project
                "\"NAME\" TEXT," + // 4: name
                "\"DEFAULT_AEQ\" TEXT," + // 5: default_aeq
                "\"CALCULATE_BY_SPECIES\" INTEGER," + // 6: calculate_by_species
                "\"REGION\" TEXT," + // 7: region
                "\"ROOT_TO_SHOOT_RATIO\" REAL," + // 8: root_to_shoot_ratio
                "\"MAPPED_DIMENSIONS\" TEXT," + // 9: mapped_dimensions
                "\"REPORTED_DIMENSIONS\" TEXT," + // 10: reported_dimensions
                "\"CENTER_POINT_TYPE\" TEXT," + // 11: center_point_type
                "\"CP_COORD_LATITUDE\" REAL," + // 12: cp_coord_latitude
                "\"CP_COORD_LONGITUDE\" REAL," + // 13: cp_coord_longitude
                "\"REPORTED_SHAPE\" INTEGER," + // 14: reported_shape
                "\"MAPPED_SHAPE\" INTEGER," + // 15: mapped_shape
                "\"HAS_SOIL_DATA\" INTEGER," + // 16: has_soil_data
                "\"HAS_BIOMASS_DATA\" INTEGER," + // 17: has_biomass_data
                "\"HAS_DEADWOOD_DATA\" INTEGER," + // 18: has_deadwood_data
                "\"HAS_LITTER_DATA\" INTEGER," + // 19: has_litter_data
                "\"MAPPED_AREA\" REAL," + // 20: mapped_area
                "\"REPORTED_AREA\" REAL," + // 21: reported_area
                "\"AREA\" REAL," + // 22: area
                "\"TREE_SPECIES_COUNT\" INTEGER," + // 23: tree_species_count
                "\"TREE_COUNT\" INTEGER," + // 24: tree_count
                "\"FILE_NAME\" TEXT," + // 25: fileName
                "\"IMAGE_FILE_PATH\" TEXT," + // 26: image_file_path
                "\"PHOTO_DIRECTION\" TEXT," + // 27: photo_direction
                "\"PHOTO_DATE\" INTEGER);"); // 28: photo_date
    }

    /** Drops the underlying database table. */
    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "\"PLOT\"";
        db.execSQL(sql);
    }

    /** @inheritdoc */
    @Override
    protected void bindValues(SQLiteStatement stmt, Plot entity) {
        stmt.clearBindings();
 
        Long id = entity.getId();
        if (id != null) {
            stmt.bindLong(1, id);
        }
 
        String url = entity.getUrl();
        if (url != null) {
            stmt.bindString(2, url);
        }
 
        Integer parcel = entity.getParcel();
        if (parcel != null) {
            stmt.bindLong(3, parcel);
        }
 
        Integer project = entity.getProject();
        if (project != null) {
            stmt.bindLong(4, project);
        }
 
        String name = entity.getName();
        if (name != null) {
            stmt.bindString(5, name);
        }
 
        String default_aeq = entity.getDefault_aeq();
        if (default_aeq != null) {
            stmt.bindString(6, default_aeq);
        }
 
        Boolean calculate_by_species = entity.getCalculate_by_species();
        if (calculate_by_species != null) {
            stmt.bindLong(7, calculate_by_species ? 1L: 0L);
        }
 
        String region = entity.getRegion();
        if (region != null) {
            stmt.bindString(8, region);
        }
 
        Float root_to_shoot_ratio = entity.getRoot_to_shoot_ratio();
        if (root_to_shoot_ratio != null) {
            stmt.bindDouble(9, root_to_shoot_ratio);
        }
 
        String mapped_dimensions = entity.getMapped_dimensions();
        if (mapped_dimensions != null) {
            stmt.bindString(10, mapped_dimensions);
        }
 
        String reported_dimensions = entity.getReported_dimensions();
        if (reported_dimensions != null) {
            stmt.bindString(11, reported_dimensions);
        }
 
        String center_point_type = entity.getCenter_point_type();
        if (center_point_type != null) {
            stmt.bindString(12, center_point_type);
        }
 
        Double cp_coord_latitude = entity.getCp_coord_latitude();
        if (cp_coord_latitude != null) {
            stmt.bindDouble(13, cp_coord_latitude);
        }
 
        Double cp_coord_longitude = entity.getCp_coord_longitude();
        if (cp_coord_longitude != null) {
            stmt.bindDouble(14, cp_coord_longitude);
        }
 
        Short reported_shape = entity.getReported_shape();
        if (reported_shape != null) {
            stmt.bindLong(15, reported_shape);
        }
 
        Short mapped_shape = entity.getMapped_shape();
        if (mapped_shape != null) {
            stmt.bindLong(16, mapped_shape);
        }
 
        Boolean has_soil_data = entity.getHas_soil_data();
        if (has_soil_data != null) {
            stmt.bindLong(17, has_soil_data ? 1L: 0L);
        }
 
        Boolean has_biomass_data = entity.getHas_biomass_data();
        if (has_biomass_data != null) {
            stmt.bindLong(18, has_biomass_data ? 1L: 0L);
        }
 
        Boolean has_deadwood_data = entity.getHas_deadwood_data();
        if (has_deadwood_data != null) {
            stmt.bindLong(19, has_deadwood_data ? 1L: 0L);
        }
 
        Boolean has_litter_data = entity.getHas_litter_data();
        if (has_litter_data != null) {
            stmt.bindLong(20, has_litter_data ? 1L: 0L);
        }
 
        Float mapped_area = entity.getMapped_area();
        if (mapped_area != null) {
            stmt.bindDouble(21, mapped_area);
        }
 
        Float reported_area = entity.getReported_area();
        if (reported_area != null) {
            stmt.bindDouble(22, reported_area);
        }
 
        Float area = entity.getArea();
        if (area != null) {
            stmt.bindDouble(23, area);
        }
 
        Integer tree_species_count = entity.getTree_species_count();
        if (tree_species_count != null) {
            stmt.bindLong(24, tree_species_count);
        }
 
        Integer tree_count = entity.getTree_count();
        if (tree_count != null) {
            stmt.bindLong(25, tree_count);
        }
 
        String fileName = entity.getFileName();
        if (fileName != null) {
            stmt.bindString(26, fileName);
        }
 
        String image_file_path = entity.getImage_file_path();
        if (image_file_path != null) {
            stmt.bindString(27, image_file_path);
        }
 
        String photo_direction = entity.getPhoto_direction();
        if (photo_direction != null) {
            stmt.bindString(28, photo_direction);
        }
 
        java.util.Date photo_date = entity.getPhoto_date();
        if (photo_date != null) {
            stmt.bindLong(29, photo_date.getTime());
        }
    }

    @Override
    protected void attachEntity(Plot entity) {
        super.attachEntity(entity);
        entity.__setDaoSession(daoSession);
    }

    /** @inheritdoc */
    @Override
    public Long readKey(Cursor cursor, int offset) {
        return cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0);
    }    

    /** @inheritdoc */
    @Override
    public Plot readEntity(Cursor cursor, int offset) {
        Plot entity = new Plot( //
            cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0), // id
            cursor.isNull(offset + 1) ? null : cursor.getString(offset + 1), // url
            cursor.isNull(offset + 2) ? null : cursor.getInt(offset + 2), // parcel
            cursor.isNull(offset + 3) ? null : cursor.getInt(offset + 3), // project
            cursor.isNull(offset + 4) ? null : cursor.getString(offset + 4), // name
            cursor.isNull(offset + 5) ? null : cursor.getString(offset + 5), // default_aeq
            cursor.isNull(offset + 6) ? null : cursor.getShort(offset + 6) != 0, // calculate_by_species
            cursor.isNull(offset + 7) ? null : cursor.getString(offset + 7), // region
            cursor.isNull(offset + 8) ? null : cursor.getFloat(offset + 8), // root_to_shoot_ratio
            cursor.isNull(offset + 9) ? null : cursor.getString(offset + 9), // mapped_dimensions
            cursor.isNull(offset + 10) ? null : cursor.getString(offset + 10), // reported_dimensions
            cursor.isNull(offset + 11) ? null : cursor.getString(offset + 11), // center_point_type
            cursor.isNull(offset + 12) ? null : cursor.getDouble(offset + 12), // cp_coord_latitude
            cursor.isNull(offset + 13) ? null : cursor.getDouble(offset + 13), // cp_coord_longitude
            cursor.isNull(offset + 14) ? null : cursor.getShort(offset + 14), // reported_shape
            cursor.isNull(offset + 15) ? null : cursor.getShort(offset + 15), // mapped_shape
            cursor.isNull(offset + 16) ? null : cursor.getShort(offset + 16) != 0, // has_soil_data
            cursor.isNull(offset + 17) ? null : cursor.getShort(offset + 17) != 0, // has_biomass_data
            cursor.isNull(offset + 18) ? null : cursor.getShort(offset + 18) != 0, // has_deadwood_data
            cursor.isNull(offset + 19) ? null : cursor.getShort(offset + 19) != 0, // has_litter_data
            cursor.isNull(offset + 20) ? null : cursor.getFloat(offset + 20), // mapped_area
            cursor.isNull(offset + 21) ? null : cursor.getFloat(offset + 21), // reported_area
            cursor.isNull(offset + 22) ? null : cursor.getFloat(offset + 22), // area
            cursor.isNull(offset + 23) ? null : cursor.getInt(offset + 23), // tree_species_count
            cursor.isNull(offset + 24) ? null : cursor.getInt(offset + 24), // tree_count
            cursor.isNull(offset + 25) ? null : cursor.getString(offset + 25), // fileName
            cursor.isNull(offset + 26) ? null : cursor.getString(offset + 26), // image_file_path
            cursor.isNull(offset + 27) ? null : cursor.getString(offset + 27), // photo_direction
            cursor.isNull(offset + 28) ? null : new java.util.Date(cursor.getLong(offset + 28)) // photo_date
        );
        return entity;
    }
     
    /** @inheritdoc */
    @Override
    public void readEntity(Cursor cursor, Plot entity, int offset) {
        entity.setId(cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0));
        entity.setUrl(cursor.isNull(offset + 1) ? null : cursor.getString(offset + 1));
        entity.setParcel(cursor.isNull(offset + 2) ? null : cursor.getInt(offset + 2));
        entity.setProject(cursor.isNull(offset + 3) ? null : cursor.getInt(offset + 3));
        entity.setName(cursor.isNull(offset + 4) ? null : cursor.getString(offset + 4));
        entity.setDefault_aeq(cursor.isNull(offset + 5) ? null : cursor.getString(offset + 5));
        entity.setCalculate_by_species(cursor.isNull(offset + 6) ? null : cursor.getShort(offset + 6) != 0);
        entity.setRegion(cursor.isNull(offset + 7) ? null : cursor.getString(offset + 7));
        entity.setRoot_to_shoot_ratio(cursor.isNull(offset + 8) ? null : cursor.getFloat(offset + 8));
        entity.setMapped_dimensions(cursor.isNull(offset + 9) ? null : cursor.getString(offset + 9));
        entity.setReported_dimensions(cursor.isNull(offset + 10) ? null : cursor.getString(offset + 10));
        entity.setCenter_point_type(cursor.isNull(offset + 11) ? null : cursor.getString(offset + 11));
        entity.setCp_coord_latitude(cursor.isNull(offset + 12) ? null : cursor.getDouble(offset + 12));
        entity.setCp_coord_longitude(cursor.isNull(offset + 13) ? null : cursor.getDouble(offset + 13));
        entity.setReported_shape(cursor.isNull(offset + 14) ? null : cursor.getShort(offset + 14));
        entity.setMapped_shape(cursor.isNull(offset + 15) ? null : cursor.getShort(offset + 15));
        entity.setHas_soil_data(cursor.isNull(offset + 16) ? null : cursor.getShort(offset + 16) != 0);
        entity.setHas_biomass_data(cursor.isNull(offset + 17) ? null : cursor.getShort(offset + 17) != 0);
        entity.setHas_deadwood_data(cursor.isNull(offset + 18) ? null : cursor.getShort(offset + 18) != 0);
        entity.setHas_litter_data(cursor.isNull(offset + 19) ? null : cursor.getShort(offset + 19) != 0);
        entity.setMapped_area(cursor.isNull(offset + 20) ? null : cursor.getFloat(offset + 20));
        entity.setReported_area(cursor.isNull(offset + 21) ? null : cursor.getFloat(offset + 21));
        entity.setArea(cursor.isNull(offset + 22) ? null : cursor.getFloat(offset + 22));
        entity.setTree_species_count(cursor.isNull(offset + 23) ? null : cursor.getInt(offset + 23));
        entity.setTree_count(cursor.isNull(offset + 24) ? null : cursor.getInt(offset + 24));
        entity.setFileName(cursor.isNull(offset + 25) ? null : cursor.getString(offset + 25));
        entity.setImage_file_path(cursor.isNull(offset + 26) ? null : cursor.getString(offset + 26));
        entity.setPhoto_direction(cursor.isNull(offset + 27) ? null : cursor.getString(offset + 27));
        entity.setPhoto_date(cursor.isNull(offset + 28) ? null : new java.util.Date(cursor.getLong(offset + 28)));
     }
    
    /** @inheritdoc */
    @Override
    protected Long updateKeyAfterInsert(Plot entity, long rowId) {
        entity.setId(rowId);
        return rowId;
    }
    
    /** @inheritdoc */
    @Override
    public Long getKey(Plot entity) {
        if(entity != null) {
            return entity.getId();
        } else {
            return null;
        }
    }

    /** @inheritdoc */
    @Override    
    protected boolean isEntityUpdateable() {
        return true;
    }
    
}
